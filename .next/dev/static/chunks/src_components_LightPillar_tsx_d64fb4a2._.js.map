{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/sanse/Code/github.com/SanseDev/fair-swap/src/components/LightPillar.tsx"],"sourcesContent":["\"use client\";\n\nimport { useRef, useEffect, useState } from 'react';\nimport * as THREE from 'three';\nimport './LightPillar.css';\n\ninterface LightPillarProps {\n  topColor?: string;\n  bottomColor?: string;\n  intensity?: number;\n  rotationSpeed?: number;\n  interactive?: boolean;\n  className?: string;\n  glowAmount?: number;\n  pillarWidth?: number;\n  pillarHeight?: number;\n  noiseIntensity?: number;\n  mixBlendMode?: React.CSSProperties['mixBlendMode'];\n  pillarRotation?: number;\n}\n\nconst LightPillar = ({\n  topColor = '#5227FF',\n  bottomColor = '#FF9FFC',\n  intensity = 1.0,\n  rotationSpeed = 0.3,\n  interactive = false,\n  className = '',\n  glowAmount = 0.005,\n  pillarWidth = 3.0,\n  pillarHeight = 0.4,\n  noiseIntensity = 0.5,\n  mixBlendMode = 'screen',\n  pillarRotation = 0\n}: LightPillarProps) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const rafRef = useRef<number | null>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const materialRef = useRef<THREE.ShaderMaterial | null>(null);\n  const sceneRef = useRef<THREE.Scene | null>(null);\n  const cameraRef = useRef<THREE.OrthographicCamera | null>(null);\n  const geometryRef = useRef<THREE.PlaneGeometry | null>(null);\n  const mouseRef = useRef(new THREE.Vector2(0, 0));\n  const timeRef = useRef(0);\n  const [webGLSupported, setWebGLSupported] = useState(true);\n\n  // Check WebGL support\n  useEffect(() => {\n    const canvas = document.createElement('canvas');\n    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n    if (!gl) {\n      setWebGLSupported(false);\n      console.warn('WebGL is not supported in this browser');\n    }\n  }, []);\n\n  useEffect(() => {\n    if (!containerRef.current || !webGLSupported) return;\n\n    const container = containerRef.current;\n    const width = container.clientWidth;\n    const height = container.clientHeight;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    sceneRef.current = scene;\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n    cameraRef.current = camera;\n\n    let renderer: THREE.WebGLRenderer;\n    try {\n      renderer = new THREE.WebGLRenderer({\n        antialias: false,\n        alpha: true,\n        powerPreference: 'high-performance',\n        precision: 'lowp',\n        stencil: false,\n        depth: false\n      });\n    } catch (error) {\n      console.error('Failed to create WebGL renderer:', error);\n      setWebGLSupported(false);\n      return;\n    }\n\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    container.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Convert hex colors to RGB\n    const parseColor = (hex: string) => {\n      const color = new THREE.Color(hex);\n      return new THREE.Vector3(color.r, color.g, color.b);\n    };\n\n    // Shader material\n    const vertexShader = `\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 1.0);\n      }\n    `;\n\n    const fragmentShader = `\n      uniform float uTime;\n      uniform vec2 uResolution;\n      uniform vec2 uMouse;\n      uniform vec3 uTopColor;\n      uniform vec3 uBottomColor;\n      uniform float uIntensity;\n      uniform bool uInteractive;\n      uniform float uGlowAmount;\n      uniform float uPillarWidth;\n      uniform float uPillarHeight;\n      uniform float uNoiseIntensity;\n      uniform float uPillarRotation;\n      varying vec2 vUv;\n\n      const float PI = 3.141592653589793;\n      const float EPSILON = 0.001;\n      const float E = 2.71828182845904523536;\n      const float HALF = 0.5;\n\n      mat2 rot(float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n        return mat2(c, -s, s, c);\n      }\n\n      // Procedural noise function\n      float noise(vec2 coord) {\n        float G = E;\n        vec2 r = (G * sin(G * coord));\n        return fract(r.x * r.y * (1.0 + coord.x));\n      }\n\n      // Apply layered wave deformation to position\n      vec3 applyWaveDeformation(vec3 pos, float timeOffset) {\n        float frequency = 1.0;\n        float amplitude = 1.0;\n        vec3 deformed = pos;\n        \n        for(float i = 0.0; i < 4.0; i++) {\n          deformed.xz *= rot(0.4);\n          float phase = timeOffset * i * 2.0;\n          vec3 oscillation = cos(deformed.zxy * frequency - phase);\n          deformed += oscillation * amplitude;\n          frequency *= 2.0;\n          amplitude *= HALF;\n        }\n        return deformed;\n      }\n\n      // Polynomial smooth blending between two values\n      float blendMin(float a, float b, float k) {\n        float scaledK = k * 4.0;\n        float h = max(scaledK - abs(a - b), 0.0);\n        return min(a, b) - h * h * 0.25 / scaledK;\n      }\n\n      float blendMax(float a, float b, float k) {\n        return -blendMin(-a, -b, k);\n      }\n\n      void main() {\n        vec2 fragCoord = vUv * uResolution;\n        vec2 uv = (fragCoord * 2.0 - uResolution) / uResolution.y;\n        \n        // Apply 2D rotation to UV coordinates\n        float rotAngle = uPillarRotation * PI / 180.0;\n        uv *= rot(rotAngle);\n\n        vec3 origin = vec3(0.0, 0.0, -10.0);\n        vec3 direction = normalize(vec3(uv, 1.0));\n\n        float maxDepth = 50.0;\n        float depth = 0.1;\n\n        mat2 rotX = rot(uTime * 0.3);\n        if(uInteractive && length(uMouse) > 0.0) {\n          rotX = rot(uMouse.x * PI * 2.0);\n        }\n\n        vec3 color = vec3(0.0);\n        \n        for(float i = 0.0; i < 100.0; i++) {\n          vec3 pos = origin + direction * depth;\n          pos.xz *= rotX;\n\n          // Apply vertical scaling and wave deformation\n          vec3 deformed = pos;\n          deformed.y *= uPillarHeight;\n          deformed = applyWaveDeformation(deformed + vec3(0.0, uTime, 0.0), uTime);\n          \n          // Calculate distance field using cosine pattern\n          vec2 cosinePair = cos(deformed.xz);\n          float fieldDistance = length(cosinePair) - 0.2;\n          \n          // Radial boundary constraint\n          float radialBound = length(pos.xz) - uPillarWidth;\n          fieldDistance = blendMax(radialBound, fieldDistance, 1.0);\n          fieldDistance = abs(fieldDistance) * 0.15 + 0.01;\n\n          vec3 gradient = mix(uBottomColor, uTopColor, smoothstep(15.0, -15.0, pos.y));\n          color += gradient * pow(1.0 / fieldDistance, 1.0);\n\n          if(fieldDistance < EPSILON || depth > maxDepth) break;\n          depth += fieldDistance;\n        }\n\n        // Normalize by pillar width to maintain consistent glow regardless of size\n        float widthNormalization = uPillarWidth / 3.0;\n        color = tanh(color * uGlowAmount / widthNormalization);\n        \n        // Add noise postprocessing\n        float rnd = noise(gl_FragCoord.xy);\n        color -= rnd / 15.0 * uNoiseIntensity;\n        \n        gl_FragColor = vec4(color * uIntensity, 1.0);\n      }\n    `;\n\n    const material = new THREE.ShaderMaterial({\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        uTime: { value: 0 },\n        uResolution: { value: new THREE.Vector2(width, height) },\n        uMouse: { value: mouseRef.current },\n        uTopColor: { value: parseColor(topColor) },\n        uBottomColor: { value: parseColor(bottomColor) },\n        uIntensity: { value: intensity },\n        uInteractive: { value: interactive },\n        uGlowAmount: { value: glowAmount },\n        uPillarWidth: { value: pillarWidth },\n        uPillarHeight: { value: pillarHeight },\n        uNoiseIntensity: { value: noiseIntensity },\n        uPillarRotation: { value: pillarRotation }\n      },\n      transparent: true,\n      depthWrite: false,\n      depthTest: false\n    });\n    materialRef.current = material;\n\n    const geometry = new THREE.PlaneGeometry(2, 2);\n    geometryRef.current = geometry;\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n\n    // Mouse interaction - throttled for performance\n    let mouseMoveTimeout: number | null = null;\n    const handleMouseMove = (event: MouseEvent) => {\n      if (!interactive) return;\n\n      if (mouseMoveTimeout) return;\n\n      mouseMoveTimeout = window.setTimeout(() => {\n        mouseMoveTimeout = null;\n      }, 16); // ~60fps throttle\n\n      const rect = container.getBoundingClientRect();\n      const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n      const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n      mouseRef.current.set(x, y);\n    };\n\n    if (interactive) {\n      container.addEventListener('mousemove', handleMouseMove, { passive: true } as EventListenerOptions);\n    }\n\n    // Animation loop with fixed timestep\n    let lastTime = performance.now();\n    const targetFPS = 60;\n    const frameTime = 1000 / targetFPS;\n\n    const animate = (currentTime: number) => {\n      if (!materialRef.current || !rendererRef.current || !sceneRef.current || !cameraRef.current) return;\n\n      const deltaTime = currentTime - lastTime;\n\n      if (deltaTime >= frameTime) {\n        timeRef.current += 0.016 * rotationSpeed;\n        materialRef.current.uniforms.uTime.value = timeRef.current;\n        rendererRef.current.render(sceneRef.current, cameraRef.current);\n        lastTime = currentTime - (deltaTime % frameTime);\n      }\n\n      rafRef.current = requestAnimationFrame(animate);\n    };\n    rafRef.current = requestAnimationFrame(animate);\n\n    // Handle resize with debouncing\n    let resizeTimeout: number | null = null;\n    const handleResize = () => {\n      if (resizeTimeout) {\n        clearTimeout(resizeTimeout);\n      }\n\n      resizeTimeout = window.setTimeout(() => {\n        if (!rendererRef.current || !materialRef.current || !containerRef.current) return;\n        const newWidth = containerRef.current.clientWidth;\n        const newHeight = containerRef.current.clientHeight;\n        rendererRef.current.setSize(newWidth, newHeight);\n        materialRef.current.uniforms.uResolution.value.set(newWidth, newHeight);\n      }, 150);\n    };\n\n    window.addEventListener('resize', handleResize, { passive: true });\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (interactive && container) {\n        container.removeEventListener('mousemove', handleMouseMove as EventListener);\n      }\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n      if (rendererRef.current) {\n        rendererRef.current.dispose();\n        rendererRef.current.forceContextLoss();\n        if (container && rendererRef.current.domElement && container.contains(rendererRef.current.domElement)) {\n          container.removeChild(rendererRef.current.domElement);\n        }\n      }\n      if (materialRef.current) {\n        materialRef.current.dispose();\n      }\n      if (geometryRef.current) {\n        geometryRef.current.dispose();\n      }\n\n      rendererRef.current = null;\n      materialRef.current = null;\n      sceneRef.current = null;\n      cameraRef.current = null;\n      geometryRef.current = null;\n      rafRef.current = null;\n    };\n  }, [\n    topColor,\n    bottomColor,\n    intensity,\n    rotationSpeed,\n    interactive,\n    glowAmount,\n    pillarWidth,\n    pillarHeight,\n    noiseIntensity,\n    pillarRotation,\n    webGLSupported\n  ]);\n\n  if (!webGLSupported) {\n    return (\n      <div className={`light-pillar-fallback ${className}`} style={{ mixBlendMode }}>\n        WebGL not supported\n      </div>\n    );\n  }\n\n  return <div ref={containerRef} className={`light-pillar-container ${className}`} style={{ mixBlendMode }} />;\n};\n\nexport default LightPillar;\n\n"],"names":[],"mappings":"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"}}]
}